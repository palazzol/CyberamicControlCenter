                                ;
                                ;       Disassembled by:
                                ;               DASMx object code disassembler
                                ;               (c) Copyright 1996-2003   Conquest Consultants
                                ;               Version 1.40 (Oct 18 2003)
                                ;
                                ;       File:           halfchuck.bin
                                ;
                                ;       Size:           1024 bytes
                                ;       Checksum:       275F
                                ;       CRC-32:         3111EF44
                                ;
                                ;       Date:           Thu Feb 29 14:34:43 2024
                                ;
                                ;       CPU:            MOS Technology 6502 (MCS6500 family)
                                ;
                                ;
                                ;
                                        org     $1C00
                                ;
1C00                            RESET:
1C00 : D8               " "             cld
1C01 : 78               "x"             sei                                             ; no decimal mode
1C02 : A2 F0            "  "            ldx     #$F0                                    ; interrupts are not used
1C04 : 9A               " "             txs                                             ; stack is at 0x01F0
1C05 : A9 00            "  "            lda     #$00                                    ; Clear and Test RAM 
1C07 : A2 10            "  "            ldx     #$10                                    ; from 0x0010 to 0x007F
1C09                            L1C09:
1C09 : 95 00            "  "            sta     RAM_start,x
1C0B : E8               " "             inx
1C0C : E0 80            "  "            cpx     #$80
1C0E : D0 F9            "  "            bne     L1C09

1C10 : A9 00            "  "            lda     #$00                                    ; Initialize these registers to 0x00
1C12 : 8D 01 03         "   "           sta     transport_control_reg_a                 ; Clear transport control A, select DDRA
1C15 : 8D 00 03         "   "           sta     transport_periph/ddr_reg_a              ; UART data inputs
1C18 : 8D 81 03         "   "           sta     audio_control_reg_a                     ; Clear audio control A, select DDRA
1C1B : 8D 80 03         "   "           sta     audio_periph/ddr_reg_a                  ; Comparator inputs
1C1E : 8D 83 03         "   "           sta     audio_control_reg_b                     ; Clear audio control B
1C21 : 8D 05 02         "   "           sta     U18_edge_detect_control_DI_pos          ; Detect PROG button release       
1C24 : 8D 03 03         "   "           sta     transport_control_reg_b                 ; Clear transport control B, select DDRB
1C27 : 8D 01 02         "   "           sta     U18_DDRA                                ; Buttons are inputs

1C2A : A9 02            "  "            lda     #$02
1C2C : 8D 81 02         "   "           sta     U19_DDRA                                ; AGC and MIKESW are inputs, RESET Light output

1C2F : A9 FF            "  "            lda     #$FF
1C31 : 8D 82 03         "   "           sta     audio_periph/ddr_reg_b                  ; DAC08 outputs
1C34 : 8D 03 02         "   "           sta     U18_DDRB                                ; Button lights are outputs
1C37 : 8D 83 02         "   "           sta     U19_DDRB                                ; CPU card lights are outputs

1C3A : A9 FC            "  "            lda     #$FC
1C3C : 8D 02 03         "   "           sta     transport_periph/ddr_reg_b              ; transport control, chip control are outputs, PB1 & PB0 inputs           

1C3F : A9 2E            " ."            lda     #$2E
1C41 : 8D 01 03         "   "           sta     transport_control_reg_a                 ; transport CA2 is Read strobe (~DDR), set IRQA bit on ~DR low to high 
1C44 : 8D 03 03         "   "           sta     transport_control_reg_b                 ; transport CB2 is Write strobe (~THRL), set IRQB bit on CB1 low to high

1C47 : A9 3C            " <"            lda     #$3C
1C49 : 8D 81 03         "   "           sta     audio_control_reg_a                     ; CA2 High - Disable BG Audio
1C4C : 8D 83 03         "   "           sta     audio_control_reg_b                     ; CB2 high - Disable Tape Audio

1C4F : A9 64            " d"            lda     #$64
1C51 : 85 53            " S"            sta     RAM_53                                  ; 100 - init 1 msec master counter

1C53 : A9 64            " d"            lda     #$64
1C55 : 85 56            " V"            sta     RAM_56                                  ; 100 - init a 1000 sec = 16 min counter?

1C57 : A9 F0            "  "            lda     #$F0
1C59 : 8D 82 03         "   "           sta     audio_periph/ddr_reg_b                  ; DAC08 outputs - upper 4 bits only?
1C5C : 8D 82 02         "   "           sta     U19_PORTB                               ; turn on CPU LEDs 5-8

1C5F : A9 10            "  "            lda     #$10
1C61 : 20 60 1D         " ` "           jsr     L1D60                                   ; STOP tape

1C64 : A9 28            " ("            lda     #$28                                    ; this will count 4 seconds
1C66 : 85 54            " T"            sta     RAM_54

1C68 : A9 64            " d"            lda     #$64                                    ; reset master timer
1C6A : 85 53            " S"            sta     RAM_53
1C6C                            L1C6C:
1C6C : 20 72 1E         " r "           jsr     L1E72                                   ; do not much for 4 seconds
1C6F : A5 54            " T"            lda     RAM_54
1C71 : D0 F9            "  "            bne     L1C6C
1C73                            L1C73:
1C73 : A9 40            " @"            lda     #$40
1C75 : 20 74 1D         " t "           jsr     L1D74                                   ; REWIND tape
1C78                            L1C78:
1C78 : A9 00            "  "            lda     #$00
1C7A : 85 58            " X"            sta     RAM_58                                  ; state 0?
1C7C                            L1C7C:
1C7C : 20 72 1E         " r "           jsr     L1E72                                   ; housekeeping
1C7F : AD 03 03         "   "           lda     transport_control_reg_b                 ; loop until transport CB1 rising edge
1C82 : 10 F8            "  "            bpl     L1C7C

1C84 : A9 06            "  "            lda     #$06
1C86 : 85 54            " T"            sta     RAM_54                                  ; set 0.6 second timer

1C88 : A9 64            " d"            lda     #$64                                    ; 100
1C8A : 85 53            " S"            sta     RAM_53
1C8C                            L1C8C:
1C8C : 20 72 1E         " r "           jsr     L1E72                                   ; housekeeping
1C8F : AD 03 03         "   "           lda     transport_control_reg_b                 ; loop until 100 transport CB1 rising edges or 0.6 secs expired
1C92 : 10 0B            "  "            bpl     L1C9F
1C94 : E6 58            " X"            inc     RAM_58                                  ; state1
1C96 : AD 02 03         "   "           lda     transport_periph/ddr_reg_b
1C99 : A5 58            " X"            lda     RAM_58
1C9B : C9 64            " d"            cmp     #$64
1C9D : B0 0B            "  "            bcs     L1CAA                                   ; happened 100 times, jump ahead
1C9F                            L1C9F:
1C9F : A5 54            " T"            lda     RAM_54
1CA1 : D0 E9            "  "            bne     L1C8C

1CA3 : 4C 78 1C         "Lx "           jmp     L1C78

                                ; unused instructions start
1CA6 : C9 60            " `"            cmp     #$60
1CA8 : 90 00            "  "            bcc     L1CAA
                                ; unused instructions end

                                ;
1CAA                            L1CAA:
1CAA : A9 20            "  "            lda     #$20
1CAC : 20 74 1D         " t "           jsr     L1D74                                   ; FFWD tape
1CAF : A9 19            "  "            lda     #$19
1CB1 : 85 54            " T"            sta     RAM_54                                  ; for 2.5 secs
1CB3 : A9 64            " d"            lda     #$64
1CB5 : 85 53            " S"            sta     RAM_53
1CB7                            L1CB7:
1CB7 : 20 72 1E         " r "           jsr     L1E72                                   ; do housekeeping stuff
1CBA : A5 54            " T"            lda     RAM_54
1CBC : D0 F9            "  "            bne     L1CB7

1CBE : A9 00            "  "            lda     #$00
1CC0 : 85 59            " Y"            sta     RAM_59
1CC2 : 20 83 1D         "   "           jsr     L1D83                                   ; look for start of data?
1CC5 : E6 59            " Y"            inc     RAM_59
1CC7 : A9 10            "  "            lda     #$10
1CC9 : 20 60 1D         " ` "           jsr     L1D60                                   ; STOP tape
1CCC : A9 80            "  "            lda     #$80
1CCE : 20 60 1D         " ` "           jsr     L1D60                                   ; PLAY tape
1CD1 : 20 A6 1D         "   "           jsr     L1DA6                                   ; go up to carrier?
1CD4 : A9 10            "  "            lda     #$10
1CD6 : 20 60 1D         " ` "           jsr     L1D60                                   ; STOP Tape
1CD9 : 20 33 1D         " 3 "           jsr     L1D33                                   ; init the boards and audio to stopped
1CDC : A9 00            "  "            lda     #$00
1CDE : 85 5A            " Z"            sta     RAM_5A                                  ; set state to not playing
1CE0                            L1CE0:
1CE0 : 20 72 1E         " r "           jsr     L1E72                           
1CE3 : A5 5A            " Z"            lda     RAM_5A                                  ; wait until we are triggered
1CE5 : D0 0D            "  "            bne     L1CF4                                   ; then jump
1CE7 : A9 02            "  "            lda     #$02                                    ; else
1CE9 : 8D 80 02         "   "           sta     U19_PORTA                               ; turn on RESET button light
1CEC : A9 00            "  "            lda     #$00
1CEE : 8D 02 02         "   "           sta     U18_PORTB                               ; turn on all other button lights
1CF1 : 4C E0 1C         "L  "           jmp     L1CE0
                                ;   we have been started!
1CF4                            L1CF4:
1CF4 : 20 33 1D         " 3 "           jsr     L1D33                                   ; init the boards and audio to stopped
1CF7 : A9 00            "  "            lda     #$00
1CF9 : 8D 80 02         "   "           sta     U19_PORTA                               ; turn off RESET button light
1CFC : A9 80            "  "            lda     #$80
1CFE : 8D 02 02         "   "           sta     U18_PORTB                               ; turn off all but PROG light
1D01 : A9 80            "  "            lda     #$80
1D03 : 20 60 1D         " ` "           jsr     L1D60                                   ; PLAY tape
1D06 : 20 A6 1D         "   "           jsr     L1DA6                                   ; go up to carrier?
1D09 : C6 5A            " Z"            dec     RAM_5A                                  ; no longer triggered
1D0B : 20 CC 1D         "   "           jsr     L1DCC                                   ; play a track!
1D0E : 20 33 1D         " 3 "           jsr     L1D33                                   ; init the boards and audio to stopped
1D11 : A9 30            " 0"            lda     #$30
1D13 : 85 56            " V"            sta     RAM_56                                  ; 8 minute timer?
1D15 : A9 64            " d"            lda     #$64
1D17 : 85 55            " U"            sta     RAM_55
1D19 : E6 59            " Y"            inc     RAM_59                                  ; track counter
1D1B : A5 59            " Y"            lda     RAM_59
1D1D : C9 1A            "  "            cmp     #$1A                                    ; 26?
1D1F : 90 03            "  "            bcc     L1D24
1D21 : 4C 73 1C         "Ls "           jmp     L1C73                                   ; rewind the tape after the total number of tracks are done
                                ;
1D24                            L1D24:
1D24 : 20 A6 1D         "   "           jsr     L1DA6                                   ; go up to carrier?
1D27 : A9 10            "  "            lda     #$10
1D29 : 20 60 1D         " ` "           jsr     L1D60                                   ; STOP tape
1D2C : A9 00            "  "            lda     #$00
1D2E : 85 5A            " Z"            sta     RAM_5A                                  ; no longer triggered
1D30 : 4C E0 1C         "L  "           jmp     L1CE0
                                ;
1D33                            L1D33:
1D33 : A9 3C            " <"            lda     #$3C
1D35 : 8D 83 03         "   "           sta     audio_control_reg_b                     ; CB2 High (Disable Tape Audio)
1D38 : A9 34            " 4"            lda     #$34
1D3A : 8D 81 03         "   "           sta     audio_control_reg_a                     ; CA2 Low (Enable BG Audio)
1D3D : A2 00            "  "            ldx     #$00
1D3F                            L1D3F:
1D3F : A9 30            " 0"            lda     #$30
1D41 : 95 81            "  "            sta     board_1_control_reg_a,x                 ; boardX CA2 low, DDR select
1D43 : 95 83            "  "            sta     board_1_control_reg_b,x                 ; boardX CB2 low, DDR select
1D45 : A9 FF            "  "            lda     #$FF
1D47 : 95 80            "  "            sta     board_1_periph/ddr_reg_a,x              ; all A pins to outputs
1D49 : 95 82            "  "            sta     board_1_periph/ddr_reg_b,x              ; all B pins to outputs
1D4B : A9 34            " 4"            lda     #$34
1D4D : 95 81            "  "            sta     board_1_control_reg_a,x                 ; A peripheral selected
1D4F : 95 83            "  "            sta     board_1_control_reg_b,x                 ; B peripheral selected
1D51 : A9 00            "  "            lda     #$00
1D53 : 95 80            "  "            sta     board_1_periph/ddr_reg_a,x              ; A solenoids off
1D55 : 95 82            "  "            sta     board_1_periph/ddr_reg_b,x              ; B solenoids off
1D57 : E8               " "             inx
1D58 : E8               " "             inx
1D59 : E8               " "             inx
1D5A : E8               " "             inx
1D5B : E0 20            "  "            cpx     #$20                                    ; do for boards 1-8
1D5D : 90 E0            "  "            bcc     L1D3F
1D5F : 60               "`"             rts
                                ;
                                ;       Send Transport command for 0.255 sec
                                ;       and then unassert it
                                ;       (Used for STOP and PLAY)
                                ;
1D60                            L1D60:
1D60 : 8D 02 03         "   "           sta     transport_periph/ddr_reg_b              ; enable output line
1D63 : A9 FF            "  "            lda     #$FF
1D65 : 85 50            " P"            sta     RAM_50
1D67                            L1D67:
1D67 : 20 72 1E         " r "           jsr     L1E72                                   ; check for PROG button push
1D6A : A5 50            " P"            lda     RAM_50
1D6C : D0 F9            "  "            bne     L1D67
1D6E : A9 00            "  "            lda     #$00
1D70 : 8D 02 03         "   "           sta     transport_periph/ddr_reg_b
1D73 : 60               "`"             rts
                                ;
                                ;       Send Transport command for 0.250 sec
                                ;       and keep it asserted on return
                                ;       (Used for Rewind and FFwd)
                                ;
1D74                            L1D74:
1D74 : 8D 02 03         "   "           sta     transport_periph/ddr_reg_b
1D77 : A9 FA            "  "            lda     #$FA
1D79 : 85 50            " P"            sta     RAM_50
1D7B                            L1D7B:
1D7B : 20 72 1E         " r "           jsr     L1E72
1D7E : A5 50            " P"            lda     RAM_50
1D80 : D0 F9            "  "            bne     L1D7B
1D82 : 60               "`"             rts
                                ;
                                ;       Look for header / start of data?
                                ;
1D83                            L1D83:
1D83 : A9 00            "  "            lda     #$00
1D85 : 85 58            " X"            sta     RAM_58
1D87                            L1D87:
1D87 : AD 02 03         "   "           lda     transport_periph/ddr_reg_b
1D8A : A9 0A            "  "            lda     #$0A
1D8C : 85 50            " P"            sta     RAM_50                                  ; 10 msec
1D8E : E6 58            " X"            inc     RAM_58
1D90 : A5 58            " X"            lda     RAM_58
1D92 : C9 21            " !"            cmp     #$21                                    ; wait for 330 msec?
1D94 : B0 0F            "  "            bcs     L1DA5                                   ; timeout - exit
1D96                            L1D96:
1D96 : 20 72 1E         " r "           jsr     L1E72                                   ; housekeeping
1D99 : A5 50            " P"            lda     RAM_50
1D9B : F0 E6            "  "            beq     L1D83                                   ; 10 msec done yet? then loop
1D9D : AD 03 03         "   "           lda     transport_control_reg_b                 ; transport CB1 rising edge?
1DA0 : 10 F4            "  "            bpl     L1D96                                   ; if so, extend the looping
1DA2 : 4C 87 1D         "L  "           jmp     L1D87                                   ; else loop but keep timeout going
1DA5                            L1DA5:
1DA5 : 60               "`"             rts
                                ;
1DA6                            L1DA6:
1DA6 : A9 FA            "  "            lda     #$FA
1DA8 : 85 50            " P"            sta     RAM_50                                  ; 250 msec
1DAA                            L1DAA:
1DAA : 20 72 1E         " r "           jsr     L1E72                                   ; housekeeping
1DAD : A5 50            " P"            lda     RAM_50
1DAF : D0 F9            "  "            bne     L1DAA
1DB1                            L1DB1:
1DB1 : 20 72 1E         " r "           jsr     L1E72
1DB4 : AD 02 03         "   "           lda     transport_periph/ddr_reg_b
1DB7 : 6A               "j"             ror     a
1DB8 : 90 F7            "  "            bcc     L1DB1
1DBA : A9 A0            "  "            lda     #$A0                                    ; 160 msec
1DBC : 85 50            " P"            sta     RAM_50
1DBE                            L1DBE:
1DBE : 20 72 1E         " r "           jsr     L1E72
1DC1 : AD 02 03         "   "           lda     transport_periph/ddr_reg_b
1DC4 : 6A               "j"             ror     a
1DC5 : 90 EA            "  "            bcc     L1DB1
1DC7 : A5 50            " P"            lda     RAM_50
1DC9 : D0 F3            "  "            bne     L1DBE
1DCB : 60               "`"             rts
                                ;
1DCC                            L1DCC:
1DCC : AD 00 03         "   "           lda     transport_periph/ddr_reg_a
1DCF : A9 40            " @"            lda     #$40
1DD1 : 85 82            "  "            sta     board_1_periph/ddr_reg_b                ; only Board 1 PB6 on
1DD3 : 85 86            "  "            sta     board_2_periph/ddr_reg_b                ; only Board 2 PB6 on
1DD5 : 85 8A            "  "            sta     board_3_periph/ddr_reg_b                ; only Board 3 PB6 on
1DD7 : 85 8E            "  "            sta     board_4_periph/ddr_reg_b                ; only Board 4 PB6 on
1DD9 : A9 3C            " <"            lda     #$3C
1DDB : 8D 81 03         "   "           sta     audio_control_reg_a                     ; CA2 High (Disable Other Audio)
1DDE : A9 34            " 4"            lda     #$34
1DE0 : 8D 83 03         "   "           sta     audio_control_reg_b                     ; CB2 Low (Enable Tape Audio)
1DE3                            L1DE3:
1DE3 : AD 02 03         "   "           lda     transport_periph/ddr_reg_b
1DE6 : 4A               "J"             lsr     a
1DE7 : 90 0E            "  "            bcc     L1DF7                                   ; b0=0, no carrier, exit
1DE9 : 20 72 1E         " r "           jsr     L1E72                                   ; housekeeping
1DEC : AD 01 03         "   "           lda     transport_control_reg_a                 ; Did we get a byte?
1DEF : 10 F2            "  "            bpl     L1DE3                                   ; No, loop
1DF1 : 20 09 1E         "   "           jsr     L1E09                                   ; Yes, Process Incoming Byte 
1DF4 : 4C E3 1D         "L  "           jmp     L1DE3
                                ;
1DF7                            L1DF7:
1DF7 : A9 64            " d"            lda     #$64                                    ; 100 msec
1DF9 : 85 50            " P"            sta     RAM_50
1DFB                            L1DFB:
1DFB : 20 72 1E         " r "           jsr     L1E72
1DFE : AD 02 03         "   "           lda     transport_periph/ddr_reg_b
1E01 : 4A               "J"             lsr     a
1E02 : B0 C8            "  "            bcs     L1DCC                                   ; carrier 
1E04 : A5 50            " P"            lda     RAM_50
1E06 : D0 F3            "  "            bne     L1DFB
1E08 : 60               "`"             rts
                                ;
                                ; Protocol handler
                                ;
1E09                            L1E09:
1E09 : AD 00 03         "   "           lda     transport_periph/ddr_reg_a
1E0C : 29 7F            ") "            and     #$7F                                    ; insure data is ASCII
1E0E : 85 5C            " \"            sta     RAM_5C                                  ; store it here
1E10 : 29 7E            ")~"            and     #$7E                                    ; ignore bottom bit
1E12 : C9 22            " ""            cmp     #$22                                    ; is it 0x22 or 0x23?
1E14 : F0 3A            " :"            beq     L1E50                                   ; if so, process as channel
1E16 : C9 32            " 2"            cmp     #$32                                    ; is it < 0x32 ?
1E18 : 90 4F            " O"            bcc     L1E69                                   ; ignore it
1E1A : C9 3A            " :"            cmp     #$3A                                    ; is it < 0x3A
1E1C : 90 32            " 2"            bcc     L1E50                                   ; process as channel (0x32 to 0x39)
1E1E : A5 5C            " \"            lda     RAM_5C
1E20 : C9 41            " A"            cmp     #$41                                    ; is it < 0x41?
1E22 : 90 45            " E"            bcc     L1E69                                   ; ignore it
1E24 : C9 51            " Q"            cmp     #$51                                    ; is it >= 0x51?
1E26 : B0 41            " A"            bcs     L1E69                                   ; ignore it
1E28 : A6 64            " d"            ldx     RAM_64                                  ; X = current board address
1E2A : 38               "8"             sec                                             ; (it's 0x42 to 0x50)
1E2B : E9 41            " A"            sbc     #$41                                    ; subtract 0x41
1E2D : C9 08            "  "            cmp     #$08
1E2F : 90 02            "  "            bcc     L1E33                                   ; process as command
1E31 : E8               " "             inx
1E32 : E8               " "             inx
1E33                            L1E33:
1E33 : 29 07            ") "            and     #$07                                    ; lookup bitmask in A
1E35 : A8               " "             tay
1E36 : B9 6A 1E         " j "           lda     X1E6A,y
1E39 : 85 5D            " ]"            sta     RAM_5D                                  ; store mask in RAM_5D
1E3B : A5 5E            " ^"            lda     RAM_5E
1E3D : 4A               "J"             lsr     a                                       ; get on/off in carry
1E3E : B0 09            "  "            bcs     L1E49                                   ; if on, jump
1E40 : A5 5D            " ]"            lda     RAM_5D
1E42 : 49 FF            "I "            eor     #$FF
1E44 : 35 00            "5 "            and     RAM_start,x
1E46 : 95 00            "  "            sta     RAM_start,x                             ; turn off solenoid
1E48 : 60               "`"             rts
                                ;
1E49                            L1E49:
1E49 : A5 5D            " ]"            lda     RAM_5D
1E4B : 15 00            "  "            ora     RAM_start,x
1E4D : 95 00            "  "            sta     RAM_start,x                             ; turn on solenoid
1E4F : 60               "`"             rts
                                ;
1E50                            L1E50:
1E50 : A5 5C            " \"            lda     RAM_5C                                  ; put channel byte in RAM_5E
1E52 : 85 5E            " ^"            sta     RAM_5E
1E54 : 29 7E            ")~"            and     #$7E
1E56 : C9 22            " ""            cmp     #$22
1E58 : D0 05            "  "            bne     L1E5F
1E5A : A9 98            "  "            lda     #$98                                    ; process 0x22 or 0x23
1E5C : 85 64            " d"            sta     RAM_64                                  ; set this to 0x98 - board 7
1E5E : 60               "`"             rts
                                ;
1E5F                            L1E5F:
1E5F : 38               "8"             sec                                             ; process channel
1E60 : E9 32            " 2"            sbc     #$32
1E62 : 0A               " "             asl     a                               
1E63 : 18               " "             clc
1E64 : 69 80            "i "            adc     #$80
1E66 : 85 64            " d"            sta     RAM_64                                  ; (X-0x32) * 2 + 0x80
1E68 : 60               "`"             rts
1E69                            L1E69:
1E69 : 60               "`"             rts
                                ;
                                ; bit mask table
                                ;
1E6A                            X1E6A:
1E6A : 01 02 04 08      "    "          db      $01, $02, $04, $08
1E6E : 10 20 40 80      "  @ "          db      $10, $20, $40, $80
                                ;
                                ; RAM_50 used on entry
                                ;
1E72                            L1E72:
1E72 : AD 05 02         "   "           lda     U18_edge_detect_control_DI_pos          ; Did the PROG button get pushed or timer expire?
1E75 : 85 5F            " _"            sta     RAM_5F                                  ; store this state in 5F
1E77 : F0 50            " P"            beq     L1EC9                                   ; No flags set, return
1E79 : A5 5B            " ["            lda     RAM_5B                                  ; Are we already running?
1E7B : 30 0E            "0 "            bmi     L1E8B                                   ; yes, jump ahead
1E7D : A5 5F            " _"            lda     RAM_5F                                  ; else check flags                                  
1E7F : 29 40            ")@"            and     #$40                                    ; PROG pushed?
1E81 : F0 16            "  "            beq     L1E99                                   ; if not, go to AGC
1E83 : A9 80            "  "            lda     #$80
1E85 : 85 5B            " ["            sta     RAM_5B                                  ; now we are running!
1E87 : A9 FA            "  "            lda     #$FA
1E89 : 85 51            " Q"            sta     RAM_51                                  ; 
1E8B                            L1E8B:
1E8B : A5 51            " Q"            lda     RAM_51
1E8D : D0 06            "  "            bne     L1E95
1E8F : A9 00            "  "            lda     #$00
1E91 : 85 5B            " ["            sta     RAM_5B                                  ; we are stopped
1E93 : E6 5A            " Z"            inc     RAM_5A
1E95                            L1E95:
1E95 : A5 5F            " _"            lda     RAM_5F                                  ; check timer irq bit
1E97 : 10 30            " 0"            bpl     L1EC9                                   ; if timer not expired, return

1E99                            L1E99:
1E99 : AD 04 02         "   "           lda     U18_timer                               ; read timer in U18
1E9C : 49 FF            "I "            eor     #$FF                                    ; flip the bits
1E9E : 4A               "J"             lsr     a                                       ; keep the top 5 bits
1E9F : 4A               "J"             lsr     a
1EA0 : 4A               "J"             lsr     a
1EA1 : 85 57            " W"            sta     RAM_57                                  ; store them
1EA3 : 90 02            "  "            bcc     L1EA7                                   ; bcc on timer bit D2
1EA5 : E6 57            " W"            inc     RAM_57                                  ; round up?
                                                                                        ; now RAM_57 has the number of 8us 
                                                                                        ;   intervals since timer expired
1EA7                            L1EA7:
1EA7 : A9 7A            " z"            lda     #$7A                                    ; reset timer to expire every 0x7A*8 ~= 976 usec?
1EA9 : 38               "8"             sec                                             ; with programming delays, this is 1 msec
1EAA : E5 57            " W"            sbc     RAM_57
1EAC : 8D 15 02         "   "           sta     U18_timer_8T_DI                         ; set timer
1EAF : C6 50            " P"            dec     RAM_50                                  ; decrement these timers every timer reset
1EB1 : C6 51            " Q"            dec     RAM_51
1EB3 : C6 52            " R"            dec     RAM_52
1EB5 : C6 53            " S"            dec     RAM_53
1EB7 : D0 10            "  "            bne     L1EC9                                   ; if timer RAM_53 expires, then wrap to 100
1EB9 : A9 64            " d"            lda     #$64                                    ; 100
1EBB : 85 53            " S"            sta     RAM_53
1EBD : C6 54            " T"            dec     RAM_54
1EBF : C6 55            " U"            dec     RAM_55                                  
1EC1 : D0 06            "  "            bne     L1EC9                                   ; if timer RAM_55 expires, then wrap to 100
1EC3 : A9 64            " d"            lda     #$64                                    ; 100
1EC5 : 85 55            " U"            sta     RAM_55
1EC7 : C6 56            " V"            dec     RAM_56
1EC9                            L1EC9:
1EC9 : 60               "`"             rts
                                ;
                                ; AGC table, unused
                                ;
1ECA : 03 04 06 08      "    "          db      $03, $04, $06, $08
1ECE : 10 16 20 2D      "   -"          db      $10, $16, $20, $2D
1ED2 : 40 5A 80 BF      "@Z  "          db      $40, $5A, $80, $BF
1ED6 : FF FF FF FF      "    "          db      $FF, $FF, $FF, $FF

                                ; all zeros in this gap

1EDA : 00 00 00 00      "    "          db      $00, $00, $00, $00
1EDE : 00 00 00 00      "    "          db      $00, $00, $00, $00
1EE2 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1EE6 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1EEA : 00 00 00 00      "    "          db      $00, $00, $00, $00
1EEE : 00 00 00 00      "    "          db      $00, $00, $00, $00
1EF2 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1EF6 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1EFA : 00 00 00 00      "    "          db      $00, $00, $00, $00
1EFE : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F02 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F06 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F0A : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F0E : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F12 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F16 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F1A : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F1E : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F22 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F26 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F2A : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F2E : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F32 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F36 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F3A : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F3E : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F42 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F46 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F4A : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F4E : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F52 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F56 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F5A : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F5E : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F62 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F66 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F6A : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F6E : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F72 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F76 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F7A : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F7E : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F82 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F86 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F8A : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F8E : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F92 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F96 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F9A : 00 00 00 00      "    "          db      $00, $00, $00, $00
1F9E : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FA2 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FA6 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FAA : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FAE : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FB2 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FB6 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FBA : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FBE : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FC2 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FC6 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FCA : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FCE : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FD2 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FD6 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FDA : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FDE : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FE2 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FE6 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FEA : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FEE : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FF2 : 00 00 00 00      "    "          db      $00, $00, $00, $00
1FF6 : 00 00 00 00      "    "          db      $00, $00, $00, $00
                                ;
                                ; vectors
                                ;
1FFA                            NMIVEC:
1FFA : 00 00            "  "            dw      RAM_start
1FFC                            RESETVEC:
1FFC : 00 1C            "  "            dw      RESET
1FFE                            IRQVEC:
1FFE : 00 00            "  "            dw      RAM_start

;--------------------------------------------------------------
Symbol table
============

Value           Type    Name
-----           ----    ----
0000            Data    RAM_start
0050            Data    RAM_50
0051            Data    RAM_51
0052            Data    RAM_52
0053            Data    RAM_53
0054            Data    RAM_54
0055            Data    RAM_55
0056            Data    RAM_56
0057            Data    RAM_57
0058            Data    RAM_58
0059            Data    RAM_59
005A            Data    RAM_5A
005B            Data    RAM_5B
005C            Data    RAM_5C
005D            Data    RAM_5D
005E            Data    RAM_5E
005F            Data    RAM_5F
0064            Data    RAM_64
0080            Data    board_1_periph/ddr_reg_a
0081            Data    board_1_control_reg_a
0082            Data    board_1_periph/ddr_reg_b
0083            Data    board_1_control_reg_b
0086            Data    board_2_periph/ddr_reg_b
008A            Data    board_3_periph/ddr_reg_b
008E            Data    board_4_periph/ddr_reg_b
0200            Data    U18_PORTA
0201            Data    U18_DDRA
0202            Data    U18_PORTB
0203            Data    U18_DDRB
0204            Data    U18_timer
0205            Data    U18_edge_detect_control_DI_pos
0215            Data    U18_timer_8T_DI
0280            Data    U19_PORTA
0281            Data    U19_DDRA
0282            Data    U19_PORTB
0283            Data    U19_DDRB
0300            Data    transport_periph/ddr_reg_a
0301            Data    transport_control_reg_a
0302            Data    transport_periph/ddr_reg_b
0303            Data    transport_control_reg_b
0380            Data    audio_periph/ddr_reg_a
0381            Data    audio_control_reg_a
0382            Data    audio_periph/ddr_reg_b
0383            Data    audio_control_reg_b
1C00            Code    RESET
1C09            Code    L1C09
1C6C            Code    L1C6C
1C73            Code    L1C73
1C78            Code    L1C78
1C7C            Code    L1C7C
1C8C            Code    L1C8C
1C9F            Code    L1C9F
1CAA            Code    L1CAA
1CB7            Code    L1CB7
1CE0            Code    L1CE0
1CF4            Code    L1CF4
1D24            Code    L1D24
1D33            Code    L1D33
1D3F            Code    L1D3F
1D60            Code    L1D60
1D67            Code    L1D67
1D74            Code    L1D74
1D7B            Code    L1D7B
1D83            Code    L1D83
1D87            Code    L1D87
1D96            Code    L1D96
1DA5            Code    L1DA5
1DA6            Code    L1DA6
1DAA            Code    L1DAA
1DB1            Code    L1DB1
1DBE            Code    L1DBE
1DCC            Code    L1DCC
1DE3            Code    L1DE3
1DF7            Code    L1DF7
1DFB            Code    L1DFB
1E09            Code    L1E09
1E33            Code    L1E33
1E49            Code    L1E49
1E50            Code    L1E50
1E5F            Code    L1E5F
1E69            Code    L1E69
1E6A            Data    X1E6A
1E72            Code    L1E72
1E8B            Code    L1E8B
1E95            Code    L1E95
1E99            Code    L1E99
1EA7            Code    L1EA7
1EC9            Code    L1EC9
1FFA            Data    NMIVEC
1FFC            Data    RESETVEC
1FFE            Data    IRQVEC
FFFC            Code    reset

Number of symbols:                      92

;--------------------------------------------------------------
